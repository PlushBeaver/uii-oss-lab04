# Структура программы

Программа моделирует многозадачную операционную систему и включает:

  * «ядро ОС», реализующее управление задачами и семафоры:
    `kernel.h`, `kernel.cpp`, `os.h`, `semaphore.cpp`;
  * «API ОС», к которому обращаются «пользовательские процессы»:
    `api.h`, `api.cpp`;
  * «пользовательские процессы»: `init.h`, `tasks.cpp`;
  * вспомогательные файлы: `stdcall.h`, `generator.h`, `main.cpp`.

Ядро ОС расположено в пространстве имен `OS`, API ОС — в `OS::API`.

В этом документе под ОС, ядром и задачами подразумеваются модели в программе,
а не соответствующие механизмы Windows.

## Ядро ОС

  * `kernel.h` определяет интерфейс ядра, скрывающий операции с волокнами
     и задачами.  Им пользуется планировщик выполнения задач (который нужно
     реализовать) и семафоры (которые тоже нужно реализовать).

  * `kernel.cpp` содержит два раздела: заготовку планировщика выполнения задач
    и реализацию прочих механизмов ОС, которой планировщик может пользоваться.

    * `run_kernel()` — основная функция ядра, она обращается к планировщику
      и передает управление выбранной им задаче (функция определена в `os.h`,
      потому что это единственный компонент ядра, нужный `main()`).
    * вектор `tasks` содержит таблицу задач;
    * функция `schedule()` должна вернуть один из элементов `tasks` —
      задачу, которой должно быть передано управление.

  * `semaphore.cpp` содержит класс `OS::Semaphore`, который реализует интерфейс
    семафора `OS::API::Semaphore` — методы `up()` и `down()`, пользуясь
    интерфейсом API и ядра.


## API ОС

  * `api.h` определяет интерфейс ОС, которым пользуются «процессы»:

    * `void yield()` — самая важная функция, с помощью которой процесс
      отдает управление ядру ОС;

    * `void terminate()` не только отдает управление ядру ОС, но и завершает
      задачу (меняет её состояние).  Планировщик должен удалять завершенные
      задачи из таблицы.

    * `void spawn()` позволяет запустить новую задачу, добавив её в таблицу.
      Вызвавшая задача сохраняет управление, то есть новая задача может быть
      запущена не сразу.

    * Интерфейс `Semaphore` представляет семафор, описанный в лекционном курсе.
      Функция `get_semaphore()` позволяет получить ссылку на семафор по его ID.

  * `api.cpp` реализует `yield()` и `terminate()`.


## Пользовательские процессы

  * В `init.h` объявляется функция `init_process()` — первый процесс, который
    будет запущен ядром ОС, и следовательно, только о нем ядро «знает» наперед.

  * В `tasks.cpp` определено несколько функций, моделирующих процессы.

    * Процесс, печатающий сообщение, `printer_process()`.

    * Процесс `counter_process()`, моделирующий задачу, требования которой
      меняются и непредсказуемы.  При получении управления каждый такой процесс:

        1. Выбирает случайное число *1 < N < 1000*.
        2. Ждет *N* миллисекунд.
        3. Добавляет *N* к счетчику.
        4. Печатает значение счетчика.
        5. Отдает управление ОС.

    * Процессы `producer_process()` и `consumer_process()` моделируют
      производителя и потребителя, обменивающихся полезными данными через
      очередь `numbers` и синронизирующихся через семафор.

    * Процесс `init_process()`, запускающий несколько других задач.
      (По умолчанию не запускает ничего, в комментариях указаны три набора.)

  **N. B.:** каждый процесс по завершении должен вызывать `OS::API::terminate()`!
