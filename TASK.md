# Задание

## Алгоритмы планирования

Необходимо реализовать несколько вариантов кооперативного планирования задач.
Задачи моделируются функциями в `tasks.cpp`, для тестирования можно изменять
набор запускаемых задач в функции `init_process()`.
	
Любой планировщик должен:

  1. Передавать управление одной из готовых задач (в состоянии `Ready`).
  2. Удалять из таблицы задач завершенные задачи (в состоянии `Terminated`).


### 1. Циклическое планирование

#### Алгоритм

Задачи получают управление в том порядке, в котором они расположены в списке
задач `tasks`.  За последней задачей в списке управление получает начальная.

#### Тестирование

  * Запустить две задачи печати `printer_process()`.  Символы сообщеий должны
    печататься вперемежку.  По окончании печати программа должна завершиться.

  * Запустить три задачи-счетчика `counter_process()`.  Значения счетчиков
    должны расходиться со временем всё больше.  Программа завершаться не должна.


### 2. Гарантированное планирование

#### Алгоритм

Управление должно передаваться той задаче, которая отработала наименьшее
суммарное время.  Счетчик отработанного времени следует хранить в структуре
`OS::Task`, для чего добавить в нее новое поле.  Перед передачей управления
задаче необходимо замерить текущее время (через `QueryPerformanceCounter()`
или `GetTickCount()`), а по возвращении управления планировщику — вновь сделать
это, рассчитать время, которое работала задача, и прибавить эту величину
к суммарному времени её работы.

#### Тестирование

Запустить три задачи-счетчика `counter_process()`.  При справедливом
распределении времени счетчики будут близки (в пределах 1000) даже через
длительное время (десятки секунд).


### 3. Приоритетное планирование *(необязательно)*

#### Алгоритм

Первыми получают управление задачи с наивысшим приоритетом.  Приоритет следует
хранить в структуре `Task`, для чего добавить в нее новое поле.  Установка
приоритета происходит при запуске задачи, то есть новый параметр потребуется
добавить и функции `OS::API::spawn()`.

Если задачи взаимодействуют, возникает проблема: задачи с низким приоритетом
не получат управление, пока не завершатся задачи с высоки приоритетом. Однако
требуется одновременная работа.  Поэтому алгоритм усложняется: низкоприоритетная
задача пропускается не более *N* раз, счетчик пропусков можно хранить в `Task`.
Более сложный вариант состоит в уменьшении приоритета задачи каждый раз, когда
ей передается управление (т. н. динамический приоритет).

#### Тестирование

  * Запустить две задачи печати `printer_process()`, задав им разные приоритеты.
    Сообщения должны печататься в порядке приоритетов, если проблема инверсии
    не решена в планировщике, иначе символы более приоритетного сообщения
    должны печататься чаще.

  * Запустить задачу-производителя `producer_process()` с высоким приоритетом
    и три задачи-потребителя `consumer_process()` с низким приоритетом.
    Задача-производитель должна получать управление несколько раз подряд,
    после чего должны запускаться, по одному разу, все задачи-потребители.


## Семафоры

Необходимо реализовать поддержку синхронизации задач через семафоры, для чего
реализовать методы `up()` и `down()` класса `OS::Semaphore` в `semaphore.cpp`.

Семафор должен:

  * При операции `down()` либо уменьшать счетчик (если он не равен `0`),
    либо блокировать текущий процесс и вовзращать управление планировщику.

  * При операции `up()` либо разблокировать одну из ожидающих «поднятия»
    семафора задач, либо, если таких задач нет, увеличить счетчик на `1`.

### Тестирование

Запустить задачу-производителя `producer_process()` и три задачи-потребителя
`consumer_process()`.  Планировщик должен быть не приоритетным, либо приоритеты
задач должны быть равными.  Задачи-потребители должны получать управление
не чаще, чем задача-производитель, то есть только тогда, когда в очередь
полезных данных добавлены элементы и семафор «поднят».
