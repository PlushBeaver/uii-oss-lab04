# Структура программы

Программа моделирует многозадачную операционную систему и включает:

  * «ядро ОС», реализующее управление задачами и семафоры:
    `kernel.h`, `kernel.cpp`, `os.h`, `semaphore.cpp`;
  * «API ОС», к которому обращаются «пользовательские процессы»: `api.h`;
  * «пользовательские процессы»: `init.h`, `tasks.cpp`;
  * вспомогательные файлы: `stdcall.h`, `generator.h`, `main.cpp`.

Ядро ОС расположено в пространстве имен `OS`, API ОС — в `OS::API`.

В этом документе под ОС, ядром и задачами подразумеваются модели в программе,
а не соответствующие механизмы Windows.

## Ядро ОС

  * `kernel.h` определяет интерфейс ядра, скрывающий операции с волокнами
     и задачами.  Им пользуется планировщик выполнения задач (который нужно
     реализовать) и семафоры (которые тоже нужно реализовать).

  * `kernel.cpp` содержит два раздела: заготовку планировщика выполнения задач
    и реализацию прочих механизмов ОС, которой планировщик может пользоваться.

    * `run_kernel()` — основная функция ядра, она обращается к планировщику
      и передает управление выбранной им задаче (функция определена в `os.h`,
      потому что это единственный компонент ядра, нужный `main()`).
    * вектор `tasks` содержит таблицу задач;
    * функция `schedule()` должна вернуть один из элементов `tasks` —
      задачу, которой должно быть передано управление, для чего вызывает
      одну из функций, реализующих тот или иной алгоритм планирования.

    * Макрос `klog` предназначен для печати сообщений ядра при отладке.
      Его использование показано в примере планировщика.

  * `semaphore.cpp` содержит класс `OS::Semaphore`, который реализует интерфейс
    семафора `OS::API::Semaphore` — методы `up()` и `down()`, пользуясь
    интерфейсом API и ядра.


## API ОС

`api.h` определяет интерфейс ОС, которым пользуются «процессы»:

  * `void yield()` — самая важная функция, с помощью которой процесс
    отдает управление ядру ОС;

  * `void terminate()` не только отдает управление ядру ОС, но и завершает
    задачу (меняет её состояние).  Планировщик должен удалять завершенные
    задачи из таблицы.

  * `void spawn()` позволяет запустить новую задачу, добавив её в таблицу.
    Вызвавшая задача сохраняет управление, то есть новая задача может быть
    запущена не сразу.

  * Интерфейс `Semaphore` представляет семафор, описанный в лекционном курсе.
    Функция `get_semaphore()` позволяет получить ссылку на семафор по его ID.


## Пользовательские процессы

  * В `init.h` объявляется функция `init_process()` — первый процесс, который
    будет запущен ядром ОС, и следовательно, только о нем ядро «знает» наперед.

  * В `tasks.cpp` определено несколько функций, моделирующих процессы.

    * Процесс, печатающий сообщение, `printer_process()`.

    * Процесс `counter_process()`, моделирующий задачу, требования которой
      меняются и непредсказуемы.  При получении управления каждый такой процесс:

        1. Выбирает случайное число *1 < N < 1000*.
        2. Ждет *N* миллисекунд.
        3. Добавляет *N* к счетчику.
        4. Печатает значение счетчика.
        5. Отдает управление ОС.

    * Процессы `producer_process()` и `consumer_process()` моделируют
      производителя и потребителя, обменивающихся полезными данными через
      очередь `numbers` и синронизирующихся через семафор.

    * Процесс `init_process()`, запускающий несколько других задач.
      (Нужно раскомментировать один из трех наборов.)

**N. B.:** каждый процесс по завершении должен вызывать `OS::API::terminate()`!


## Пример планировщика

В `kernel.cpp` для примера реализован алгоритм планирования «первым пришел —
первым обслужен» функцией `first_in_first_out_scheduler()`.  Благодаря этому
исходная программа при запуске исполняет сначала первый запущенный процесс,
затем второй (они печатают на экран по сообщению).
